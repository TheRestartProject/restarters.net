import { __assign, __read, __spread } from "tslib";
/* eslint-disable max-lines, @typescript-eslint/no-explicit-any */
import { getCurrentHub, init as browserInit, SDK_VERSION } from '@sentry/browser';
import { basename, getGlobalObject, logger, timestampWithMs } from '@sentry/utils';
// Mappings from operation to corresponding lifecycle hook.
var HOOKS = {
    activate: ['activated', 'deactivated'],
    create: ['beforeCreate', 'created'],
    destroy: ['beforeDestroy', 'destroyed'],
    mount: ['beforeMount', 'mounted'],
    update: ['beforeUpdate', 'updated'],
};
var COMPONENT_NAME_REGEXP = /(?:^|[-_/])(\w)/g;
var ROOT_COMPONENT_NAME = 'root';
var ANONYMOUS_COMPONENT_NAME = 'anonymous component';
/**
 * Inits the Vue SDK
 */
export function init(options) {
    if (options === void 0) { options = {}; }
    var finalOptions = __assign(__assign({ 
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        Vue: getGlobalObject().Vue, attachProps: true, logErrors: false, tracing: false }, options), { tracingOptions: __assign({ hooks: ['activate', 'mount', 'update'], timeout: 2000, trackComponents: false }, options.tracingOptions) });
    finalOptions._metadata = finalOptions._metadata || {};
    finalOptions._metadata.sdk = {
        name: 'sentry.javascript.vue',
        packages: [
            {
                name: 'npm:@sentry/vue',
                version: SDK_VERSION,
            },
        ],
        version: SDK_VERSION,
    };
    browserInit(finalOptions);
    if (finalOptions.Vue === undefined) {
        logger.warn('No Vue instance was provided. Also there is no Vue instance on the `window` object.');
        logger.warn('We will only capture global unhandled errors.');
    }
    else {
        var vueHelper = new VueHelper(finalOptions);
        vueHelper.setup();
    }
}
/** JSDoc */
var VueHelper = /** @class */ (function () {
    /**
     * @inheritDoc
     */
    function VueHelper(options) {
        var _this = this;
        /**
         * Cache holding already processed component names
         */
        this._componentsCache = {};
        /** Keep it as attribute function, to keep correct `this` binding inside the hooks callbacks  */
        // eslint-disable-next-line @typescript-eslint/typedef
        this._applyTracingHooks = function (vm) {
            // Don't attach twice, just in case
            if (vm.$options.$_sentryPerfHook) {
                return;
            }
            vm.$options.$_sentryPerfHook = true;
            var name = _this._getComponentName(vm);
            var rootMount = name === ROOT_COMPONENT_NAME;
            var spans = {};
            // Render hook starts after once event is emitted,
            // but it ends before the second event of the same type.
            //
            // Because of this, we start measuring inside the first event,
            // but finish it before it triggers, to skip the event emitter timing itself.
            var rootHandler = function (hook) {
                var now = timestampWithMs();
                // On the first handler call (before), it'll be undefined, as `$once` will add it in the future.
                // However, on the second call (after), it'll be already in place.
                if (_this._rootSpan) {
                    _this._finishRootSpan(now);
                }
                else {
                    vm.$once("hook:" + hook, function () {
                        // Create an activity on the first event call. There'll be no second call, as rootSpan will be in place,
                        // thus new event handler won't be attached.
                        var activeTransaction = getActiveTransaction();
                        if (activeTransaction) {
                            _this._rootSpan = activeTransaction.startChild({
                                description: 'Application Render',
                                op: 'Vue',
                            });
                        }
                    });
                }
            };
            var childHandler = function (hook, operation) {
                // Skip components that we don't want to track to minimize the noise and give a more granular control to the user
                var shouldTrack = Array.isArray(_this._options.tracingOptions.trackComponents)
                    ? _this._options.tracingOptions.trackComponents.indexOf(name) > -1
                    : _this._options.tracingOptions.trackComponents;
                var childOf = _this._rootSpan || getActiveTransaction();
                if (!childOf || !shouldTrack) {
                    return;
                }
                var now = timestampWithMs();
                var span = spans[operation];
                // On the first handler call (before), it'll be undefined, as `$once` will add it in the future.
                // However, on the second call (after), it'll be already in place.
                if (span) {
                    span.finish();
                    _this._finishRootSpan(now);
                }
                else {
                    vm.$once("hook:" + hook, function () {
                        if (childOf) {
                            spans[operation] = childOf.startChild({
                                description: "Vue <" + name + ">",
                                op: operation,
                            });
                        }
                    });
                }
            };
            // Each component has it's own scope, so all activities are only related to one of them
            _this._options.tracingOptions.hooks.forEach(function (operation) {
                // Retrieve corresponding hooks from Vue lifecycle.
                // eg. mount => ['beforeMount', 'mounted']
                var internalHooks = HOOKS[operation];
                if (!internalHooks) {
                    logger.warn("Unknown hook: " + operation);
                    return;
                }
                internalHooks.forEach(function (internalHook) {
                    var handler = rootMount
                        ? rootHandler.bind(_this, internalHook)
                        : childHandler.bind(_this, internalHook, operation);
                    var currentValue = vm.$options[internalHook];
                    if (Array.isArray(currentValue)) {
                        vm.$options[internalHook] = __spread([handler], currentValue);
                    }
                    else if (typeof currentValue === 'function') {
                        vm.$options[internalHook] = [handler, currentValue];
                    }
                    else {
                        vm.$options[internalHook] = [handler];
                    }
                });
            });
        };
        this._options = options;
    }
    /**
     * Attaches the error handler and starts tracing
     */
    VueHelper.prototype.setup = function () {
        this._attachErrorHandler();
        if ('tracesSampleRate' in this._options || 'tracesSampler' in this._options) {
            this._startTracing();
        }
    };
    /**
     * Extract component name from the ViewModel
     */
    VueHelper.prototype._getComponentName = function (vm) {
        // Such level of granularity is most likely not necessary, but better safe than sorry. â€” Kamil
        if (!vm) {
            return ANONYMOUS_COMPONENT_NAME;
        }
        if (vm.$root === vm) {
            return ROOT_COMPONENT_NAME;
        }
        if (!vm.$options) {
            return ANONYMOUS_COMPONENT_NAME;
        }
        if (vm.$options.name) {
            return vm.$options.name;
        }
        if (vm.$options._componentTag) {
            return vm.$options._componentTag;
        }
        // injected by vue-loader
        if (vm.$options.__file) {
            var unifiedFile = vm.$options.__file.replace(/^[a-zA-Z]:/, '').replace(/\\/g, '/');
            var filename = basename(unifiedFile, '.vue');
            return (this._componentsCache[filename] ||
                (this._componentsCache[filename] = filename.replace(COMPONENT_NAME_REGEXP, function (_, c) {
                    return c ? c.toUpperCase() : '';
                })));
        }
        return ANONYMOUS_COMPONENT_NAME;
    };
    /** Finish top-level span and activity with a debounce configured using `timeout` option */
    VueHelper.prototype._finishRootSpan = function (timestamp) {
        var _this = this;
        if (this._rootSpanTimer) {
            clearTimeout(this._rootSpanTimer);
        }
        this._rootSpanTimer = setTimeout(function () {
            // We should always finish the span, only should pop activity if using @sentry/apm
            if (_this._rootSpan) {
                _this._rootSpan.finish(timestamp);
                _this._rootSpan = undefined;
            }
        }, this._options.tracingOptions.timeout);
    };
    /** Inject configured tracing hooks into Vue's component lifecycles */
    VueHelper.prototype._startTracing = function () {
        var applyTracingHooks = this._applyTracingHooks;
        var appliedTracingHooks = setTimeout(function () {
            logger.warn("Didn't apply tracing hooks, make sure you call Sentry.init before initialzing Vue!");
        }, 500);
        this._options.Vue.mixin({
            beforeCreate: function () {
                clearTimeout(appliedTracingHooks);
                applyTracingHooks(this);
            },
        });
    };
    /** Inject Sentry's handler into owns Vue's error handler  */
    VueHelper.prototype._attachErrorHandler = function () {
        var _this = this;
        // eslint-disable-next-line @typescript-eslint/unbound-method
        var currentErrorHandler = this._options.Vue.config.errorHandler;
        this._options.Vue.config.errorHandler = function (error, vm, info) {
            var metadata = {};
            if (vm) {
                try {
                    metadata.componentName = _this._getComponentName(vm);
                    if (_this._options.attachProps) {
                        metadata.propsData = vm.$options.propsData;
                    }
                }
                catch (_oO) {
                    logger.warn('Unable to extract metadata from Vue component.');
                }
            }
            if (info) {
                metadata.lifecycleHook = info;
            }
            // Capture exception in the next event loop, to make sure that all breadcrumbs are recorded in time.
            setTimeout(function () {
                getCurrentHub().withScope(function (scope) {
                    scope.setContext('vue', metadata);
                    getCurrentHub().captureException(error);
                });
            });
            if (typeof currentErrorHandler === 'function') {
                currentErrorHandler.call(_this._options.Vue, error, vm, info);
            }
            if (_this._options.logErrors) {
                if (_this._options.Vue.util) {
                    _this._options.Vue.util.warn("Error in " + info + ": \"" + (error && error.toString()) + "\"", vm);
                }
                // eslint-disable-next-line no-console
                console.error(error);
            }
        };
    };
    return VueHelper;
}());
/** Grabs active transaction off scope, if any */
export function getActiveTransaction() {
    var _a;
    return (_a = getCurrentHub()
        .getScope()) === null || _a === void 0 ? void 0 : _a.getTransaction();
}
//# sourceMappingURL=sdk.js.map